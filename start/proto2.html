
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>概述 &#8212; protobuf-book 0.1 文档</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "xinetzone/protobuf-book");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "💬 comment");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".cell"
        const thebe_selector_input = ".cell_input div.highlight"
        const thebe_selector_output = ".cell_output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="shortcut icon" href="../_static/page-logo.jfif"/>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="编码" href="encoding.html" />
    <link rel="prev" title="proto3" href="proto3.html" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="zh_CN">
    

    <!-- Google Analytics -->
     
<link
  rel="alternate"
  type="application/atom+xml"
  href="../posts/atom.xml"
  title="Blog"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">protobuf-book 0.1 文档</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="搜索文档..." aria-label="搜索文档..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="index.html">
   快速上手
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="intro.html">
     简介
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="proto3.html">
     proto3
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     概述
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="encoding.html">
     编码
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="techniques.html">
     技术
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../tutorials/index.html">
   教程
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../tutorials/python.html">
     Python 接口
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../tutorials/python-generated.html">
     Python 生成
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../tutorials/cpp.html">
     C++ 接口
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../about/index.html">
   关于
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../CODE_OF_CONDUCT.html">
     行为准则
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../CONTRIBUTING.html">
     贡献
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../SECURITY.html">
     安全策略
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../CHANGELOG.html">
     变更日志
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  <div>
版权所有 © 2021 <a href="https://xinetzone.github.io/">xinetzone</a></div>
<div>由 <a href="https://ebp.jupyterbook.org/">EBP</a> 提供技术支持</div>
<div>语言切换<a href="/protobuf-book/">中</a>/<a href="/protobuf-book/en">英</a></div>

</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="切换导航" aria-controls="site-navigation"
                title="切换导航" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="下载此页面"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/start/proto2.md.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="下载源文件" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="列印成PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/xinetzone/protobuf-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="源库"><i
                    class="fab fa-github"></i>资料库</button></a>
        <a class="issues-button"
            href="https://github.com/xinetzone/protobuf-book/issues/new?title=Issue%20on%20page%20%2Fstart/proto2.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="打开一个问题"><i class="fas fa-lightbulb"></i>公开的问题</button></a>
        <a class="edit-button" href="https://github.com/xinetzone/protobuf-book/edit/main/docs/start/proto2.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="编辑这个页面"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="全屏模式"
        title="全屏模式"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> 导航
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   定义消息类型
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     指定字段规则
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#proto3">
     使用 proto3 消息类型
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   更新消息类型
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extensions">
   extensions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     嵌套扩展
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id7">
     选择扩展编号
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <!-- Table of contents that is only displayed when printing the page -->
    <div id="jb-print-docs-body" class="onlyprint">
        <h1>概述</h1>
        <!-- Table of contents -->
        <div id="print-main-content" class="row">
            <div class="col-12 col-md-12 pl-md-5 pr-md-5">
            <div id="jb-print-toc">
                
                <div>
                    <h2> 导航 </h2>
                </div>
                <nav aria-label="Page">
                    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   定义消息类型
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     指定字段规则
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#proto3">
     使用 proto3 消息类型
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   更新消息类型
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extensions">
   extensions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     嵌套扩展
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id7">
     选择扩展编号
    </a>
   </li>
  </ul>
 </li>
</ul>

                </nav>
            </div>
            
              <div>
                 <div class="tex2jax_ignore mathjax_ignore section" id="id1">
<h1>概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>翻译自：<a class="reference external" href="https://developers.google.cn/protocol-buffers/docs/overview">overview</a>。</p>
<p>本指南描述了如何使用协议缓冲区语言来构造你的协议缓冲区数据，包括 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件的语法和如何从你的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件生成数据访问类。它涵盖了协议缓冲区语言的  proto2 版本：关于 proto3 语法的信息，请参阅 <a class="reference internal" href="proto3.html"><span class="doc std std-doc">Proto3 语言指南</span></a>。</p>
<p>这是一个参考指南——关于使用本文档中描述的许多功能的入门的例子，请参阅你所选择的语言的 <a class="reference internal" href="../tutorials/index.html"><span class="doc std std-doc">教程</span></a>。</p>
<div class="section" id="id2">
<h2>定义消息类型<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>首先让我们看一个非常简单的例子。假设你想定义一个搜索请求的消息格式，每个搜索请求都有一个查询字符串，你感兴趣的特定结果页，以及每页的结果数量。这里是你用来定义消息类型的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">SearchRequest</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">required</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="na">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">page_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">result_per_page</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SearchRequest</span></code> 消息定义指定了三个字段（名称/值对），每一个字段代表你想在这种类型的消息中包含的数据。每个字段都有一个名称和一个类型。</p>
<div class="section" id="id3">
<h3>指定字段规则<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>你指定消息字段是以下之一：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">required</span></code>：一封格式良好的消息必须有一个这样的字段。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optional</span></code>：一份格式良好的消息可以有零个或一个这个字段（但不能超过一个）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated</span></code>：这个字段可以在一条格式良好的信息中重复任何次数（包括零）。重复值的顺序将被保留。</p></li>
</ul>
<p>由于历史原因，标量数字类型的重复字段并没有得到有效的编码。新的代码应该使用特殊选项 <code class="docutils literal notranslate"><span class="pre">[packed</span> <span class="pre">=</span> <span class="pre">true]</span></code> 来获得更有效的编码。比如说：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="k">repeated</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="k">packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">];</span>
</pre></div>
</div>
<p>你可以在 <a class="reference external" href="encoding#packed">协议缓冲区编码</a> 中找到更多关于 <code class="docutils literal notranslate"><span class="pre">packed</span></code> 编码的信息。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Required Is Forever 你应该非常小心地把字段标记为 <code class="docutils literal notranslate"><span class="pre">required</span></code>。如果在某个时候你想停止编写或发送一个 <code class="docutils literal notranslate"><span class="pre">required</span></code> 字段，那么将该字段改为 <code class="docutils literal notranslate"><span class="pre">optional</span></code> 字段就会有问题——旧的阅读器会认为没有这个字段的消息是不完整的，并可能无意中拒绝或放弃它们。你应该考虑为你的缓冲区编写特定应用的自定义验证例程。谷歌的一些工程师已经得出结论，使用必填字段弊大于利；他们更倾向于只使用可选的和重复的。然而，这种观点并不普遍。</p>
</div>
</div>
<div class="section" id="proto3">
<h3>使用 proto3 消息类型<a class="headerlink" href="#proto3" title="永久链接至标题">¶</a></h3>
<p>可以导入 proto3 消息类型并在你的 proto2 消息中使用它们，反之亦然。然而，proto2 的枚举不能用于 proto3 的语法。</p>
</div>
</div>
<div class="section" id="id4">
<h2>更新消息类型<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>如果一个现有的消息类型不再满足你的所有需求——例如，你希望消息格式有一个额外的字段——但你仍然想使用用旧格式创建的代码，不要担心！更新消息类型非常简单，不会破坏你现有的任何代码。只要记住以下规则：</p>
<ul class="simple">
<li><p>不要改变任何现有字段的字段号。</p></li>
<li><p>你添加的任何新字段都应该是可选的或重复的。这意味着任何由使用你的 “旧” 消息格式的代码序列化的消息可以被你的新生成的代码解析，因为它们不会缺少任何 <code class="docutils literal notranslate"><span class="pre">required</span></code> 元素。你应该为这些元素设置合理的默认值，这样新代码就可以与旧代码生成的消息正确地互动。同样，由你的新代码创建的消息可以被你的旧代码解析：旧的二进制文件在解析时只需忽略新字段。然而，未知字段不会被丢弃，如果消息后来被序列化，未知字段也会被一起序列化——所以如果消息被传递给新代码，新字段仍然可用。</p></li>
<li><p>非 <code class="docutils literal notranslate"><span class="pre">required</span></code> 字段可以被删除，只要字段号不会在你更新的消息类型中再次使用。你可能想重新命名这个字段，也许加上前缀 “OBSOLETE_”，或者让这个字段号保留下来，这样你的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 的未来用户就不能意外地重复使用这个号码。</p></li>
<li><p>一个非 <code class="docutils literal notranslate"><span class="pre">required</span></code> 字段可以转换为 <a class="reference external" href="#extensions">extension</a> 字段，反之亦然，只要类型和数字保持不变。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>、<code class="docutils literal notranslate"><span class="pre">uint32</span></code>、<code class="docutils literal notranslate"><span class="pre">int64</span></code>、<code class="docutils literal notranslate"><span class="pre">uint64</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 都是兼容的——这意味着你可以将一个字段从这些类型中的一个改为另一个，而不会破坏向前或向后的兼容。如果从 wire 上解析出的数字不符合相应的类型，你会得到与你在 C++ 中把数字投到该类型的相同效果（例如，如果一个 64 位的数字被读成 <code class="docutils literal notranslate"><span class="pre">int32</span></code>，它将被截断为 32 位）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sint32</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sint64</span></code> 是相互兼容的，但与其他整数类型不兼容。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 包含信息的编码版本，则嵌入式信息与字节兼容。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed32</span></code> 与 <code class="docutils literal notranslate"><span class="pre">sfixed32</span></code> 兼容，而 <code class="docutils literal notranslate"><span class="pre">fixed64</span></code> 与 <code class="docutils literal notranslate"><span class="pre">sfixed64</span></code> 兼容。</p></li>
<li><p>对于 <code class="docutils literal notranslate"><span class="pre">string</span></code>、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和消息字段，<code class="docutils literal notranslate"><span class="pre">optional</span></code> 与 <code class="docutils literal notranslate"><span class="pre">repeated</span></code> 兼容。给出重复字段的序列化数据作为输入，如果是原始类型的字段，期望这个字段是 <code class="docutils literal notranslate"><span class="pre">optional</span></code> 客户端将采取最后的输入值，如果是消息类型的字段，将合并所有输入元素。请注意，这对于数字类型，包括 bool 和 <code class="docutils literal notranslate"><span class="pre">enum</span></code>，通常是不安全的。数字类型的重复字段可以用 <a class="reference external" href="https://developers.google.cn/protocol-buffers/docs/encoding#packed"><code class="docutils literal notranslate"><span class="pre">packed</span></code></a> 的格式进行序列化，当期望有一个 <code class="docutils literal notranslate"><span class="pre">optional</span></code> 字段时，这将不能被正确解析。</p></li>
<li><p>改变默认值一般是可以的，只要你记住默认值是不会在 wire 发送的。因此，如果一个程序收到一个没有设置特定字段的消息，该程序将看到默认值，因为它是在该程序的协议版本中定义的。它不会看到发件人代码中定义的默认值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span></code> 与 <code class="docutils literal notranslate"><span class="pre">int32</span></code>、<code class="docutils literal notranslate"><span class="pre">uint32</span></code>、<code class="docutils literal notranslate"><span class="pre">int64</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint64</span></code> 在 wire 格式上是兼容的（注意，如果数值不合适，会被截断），但是要注意，当消息被反序列化时，客户端代码可能会对它们进行不同的处理。值得注意的是，当消息被反序列化时，未被识别的 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 值会被丢弃，这使得字段的 <code class="docutils literal notranslate"><span class="pre">has..</span></code> 访问器返回 <code class="docutils literal notranslate"><span class="pre">false</span></code>，其 <code class="docutils literal notranslate"><span class="pre">getter</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 定义中列出的第一个值，或者默认值（如果指定了一个）。在重复 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 字段的情况下，任何未被识别的值都会从列表中剥离出来。然而，一个整数字段将始终保留其值。正因为如此，当把一个整数升级为 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 时，你需要非常小心，以免在电线上收到超界的 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 值。</p></li>
<li><p>在当前的 Java 和 C++ 实现中，当未识别的 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 值被剥离出来时，它们会与其他未知字段一起被存储。如果这些数据被序列化，然后被识别这些值的客户端重新解析，这可能导致奇怪的行为。在可选字段的情况下，即使在原始消息被反序列化后写了一个新的值，旧的值仍会被识别它的客户端读取。在重复字段的情况下，旧值将出现在任何已识别的和新添加的值之后，这意味着顺序将不会被保留下来。</p></li>
<li><p>将一个单一的可选值改成一个新的 <code class="docutils literal notranslate"><span class="pre">oneof</span></code> 的成员是安全的，而且二进制兼容。将多个可选字段移入一个新的 <code class="docutils literal notranslate"><span class="pre">oneof</span></code> 中可能是安全的，如果你确信没有代码同时设置多个字段的话。将任何字段移入一个现有的 <code class="docutils literal notranslate"><span class="pre">oneof</span></code> 中是不安全的。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">map&lt;K,</span> <span class="pre">V&gt;</span></code> 和相应的重复消息字段之间改变字段是二进制兼容的（关于消息布局和其他限制，见下文的 <a class="reference external" href="#maps">Maps</a>）。然而，改变的安全性取决于应用：当反序列化和重新序列化消息时，使用重复字段定义的客户端将产生一个语义上相同的结果；然而，使用 <code class="docutils literal notranslate"><span class="pre">map</span></code> 字段定义的客户端可能会重新排序条目并放弃有重复键的条目。</p></li>
</ul>
</div>
<div class="section" id="extensions">
<span id="id5"></span><h2>extensions<a class="headerlink" href="#extensions" title="永久链接至标题">¶</a></h2>
<p>扩展允许你声明信息中的一系列字段号码可用于第三方扩展。扩展是一个字段的占位符，其类型未被原始 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件定义。这允许其他 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件通过定义这些字段号的部分或全部字段的类型来增加你的消息定义。让我们看一个例子：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="k">extensions</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">199</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这说明 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 中字段号 <code class="docutils literal notranslate"><span class="pre">[100,</span> <span class="pre">199]</span></code> 的范围是保留给扩展的。其他用户现在可以在他们自己的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件中向 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 添加新的字段，这些文件可以导入你的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code>，使用你指定范围内的字段号 - 例如：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">126</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这在 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的原始定义中增加了一个名为 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 的字段，字段号为 <code class="docutils literal notranslate"><span class="pre">126</span></code>。</p>
<p>当你的用户的 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 消息被编码时，wire 的格式与用户在 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 内部定义新字段的情况完全相同。然而，你在应用程序代码中访问扩展字段的方式与访问普通字段略有不同——你生成的数据访问代码有特殊的访问器用于处理扩展字段。因此，例如，这里是你如何在 C++ 中设置 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 的值。</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">foo.SetExtension</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span>
</pre></div>
</div>
<p>同样，<code class="docutils literal notranslate"><span class="pre">Foo</span></code> 类定义了模板化的访问器 <code class="docutils literal notranslate"><span class="pre">HasExtension()</span></code>、<code class="docutils literal notranslate"><span class="pre">ClearExtension()</span></code>、<code class="docutils literal notranslate"><span class="pre">GetExtension()</span></code>、<code class="docutils literal notranslate"><span class="pre">MutableExtension()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AddExtension()</span></code>。所有的语义都与正常字段的相应生成访问器相匹配。关于使用扩展的更多信息，请参见你所选择的语言的生成代码参考。</p>
<p>扩展可以是任何字段类型，包括消息类型，但不能是 oneofs 或 maps。</p>
<div class="section" id="id6">
<h3>嵌套扩展<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>你可以在另一个类型的范围内声明扩展：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Baz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">126</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在这种情况下，访问这个扩展的 C++ 代码是：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
<span class="n">foo</span><span class="p">.</span><span class="n">SetExtension</span><span class="p">(</span><span class="n">Baz</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>换句话说，唯一的效果是，<code class="docutils literal notranslate"><span class="pre">bar</span></code> 被定义在 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 的范围内。</p>
<p>这是一个常见的混淆源。声明一个嵌套在消息类型内部的扩展块并不意味着外部类型和扩展类型之间的任何关系。特别是，上面的例子并不意味着 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的任何种类的子类。它只意味着符号 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 是在 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 的范围内声明的；它只是一个静态成员。</p>
<p>一个常见的模式是在扩展的字段类型的范围内定义扩展–例如，这里是对 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 类型的 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的扩展，其中扩展被定义为 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 的一部分：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Baz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">optional</span><span class="w"> </span><span class="n">Baz</span><span class="w"> </span><span class="na">foo_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">127</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然而，并不要求带有消息类型的扩展被定义在该类型内。你也可以这样做：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Baz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>

<span class="c1">// This can even be in a different file.</span>
<span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="n">Baz</span><span class="w"> </span><span class="na">foo_baz_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">127</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>事实上，为了避免混淆，这种语法可能是首选。如上所述，嵌套语法经常被那些还不熟悉扩展的用户误认为是子类。</p>
</div>
<div class="section" id="id7">
<h3>选择扩展编号<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>确保两个用户不使用相同的字段号为同一消息类型添加扩展名是非常重要的——如果一个扩展名被意外地解释为错误的类型，就会导致数据损坏。你可能想考虑为你的项目定义一个扩展编号惯例，以防止这种情况发生。</p>
<p>如果你的编号惯例可能涉及到扩展有非常大的字段号，你可以使用 <code class="docutils literal notranslate"><span class="pre">max</span></code> 关键字指定你的扩展范围，直到可能的最大字段号。</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extensions</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">max</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">max</span></code> 是 <span class="math notranslate nohighlight">\(2^{29} - 1\)</span>。</p>
<p>如同在选择字段号时，你的编号惯例也需要避免字段号 19000 到 19999（<code class="docutils literal notranslate"><span class="pre">FieldDescriptor::kFirstReservedNumber</span></code> 到 <code class="docutils literal notranslate"><span class="pre">FieldDescriptor::kLastReservedNumber</span></code>），因为它们被保留给协议缓冲区的实现。你可以定义一个包括这个范围的扩展范围，但是协议编译器不允许你用这些数字定义实际的扩展。</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "xinetzone/protobuf-book",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./start"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>
<div class="section">
   
</div>

              </div>
              
            </div>
        </div>
    </div>
    <div id="main-content" class="row noprint">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                 <div class="tex2jax_ignore mathjax_ignore section" id="id1">
<h1>概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>翻译自：<a class="reference external" href="https://developers.google.cn/protocol-buffers/docs/overview">overview</a>。</p>
<p>本指南描述了如何使用协议缓冲区语言来构造你的协议缓冲区数据，包括 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件的语法和如何从你的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件生成数据访问类。它涵盖了协议缓冲区语言的  proto2 版本：关于 proto3 语法的信息，请参阅 <a class="reference internal" href="proto3.html"><span class="doc std std-doc">Proto3 语言指南</span></a>。</p>
<p>这是一个参考指南——关于使用本文档中描述的许多功能的入门的例子，请参阅你所选择的语言的 <a class="reference internal" href="../tutorials/index.html"><span class="doc std std-doc">教程</span></a>。</p>
<div class="section" id="id2">
<h2>定义消息类型<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>首先让我们看一个非常简单的例子。假设你想定义一个搜索请求的消息格式，每个搜索请求都有一个查询字符串，你感兴趣的特定结果页，以及每页的结果数量。这里是你用来定义消息类型的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">SearchRequest</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">required</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="na">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">page_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">result_per_page</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SearchRequest</span></code> 消息定义指定了三个字段（名称/值对），每一个字段代表你想在这种类型的消息中包含的数据。每个字段都有一个名称和一个类型。</p>
<div class="section" id="id3">
<h3>指定字段规则<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>你指定消息字段是以下之一：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">required</span></code>：一封格式良好的消息必须有一个这样的字段。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optional</span></code>：一份格式良好的消息可以有零个或一个这个字段（但不能超过一个）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated</span></code>：这个字段可以在一条格式良好的信息中重复任何次数（包括零）。重复值的顺序将被保留。</p></li>
</ul>
<p>由于历史原因，标量数字类型的重复字段并没有得到有效的编码。新的代码应该使用特殊选项 <code class="docutils literal notranslate"><span class="pre">[packed</span> <span class="pre">=</span> <span class="pre">true]</span></code> 来获得更有效的编码。比如说：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="k">repeated</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="k">packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">];</span>
</pre></div>
</div>
<p>你可以在 <a class="reference external" href="encoding#packed">协议缓冲区编码</a> 中找到更多关于 <code class="docutils literal notranslate"><span class="pre">packed</span></code> 编码的信息。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Required Is Forever 你应该非常小心地把字段标记为 <code class="docutils literal notranslate"><span class="pre">required</span></code>。如果在某个时候你想停止编写或发送一个 <code class="docutils literal notranslate"><span class="pre">required</span></code> 字段，那么将该字段改为 <code class="docutils literal notranslate"><span class="pre">optional</span></code> 字段就会有问题——旧的阅读器会认为没有这个字段的消息是不完整的，并可能无意中拒绝或放弃它们。你应该考虑为你的缓冲区编写特定应用的自定义验证例程。谷歌的一些工程师已经得出结论，使用必填字段弊大于利；他们更倾向于只使用可选的和重复的。然而，这种观点并不普遍。</p>
</div>
</div>
<div class="section" id="proto3">
<h3>使用 proto3 消息类型<a class="headerlink" href="#proto3" title="永久链接至标题">¶</a></h3>
<p>可以导入 proto3 消息类型并在你的 proto2 消息中使用它们，反之亦然。然而，proto2 的枚举不能用于 proto3 的语法。</p>
</div>
</div>
<div class="section" id="id4">
<h2>更新消息类型<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>如果一个现有的消息类型不再满足你的所有需求——例如，你希望消息格式有一个额外的字段——但你仍然想使用用旧格式创建的代码，不要担心！更新消息类型非常简单，不会破坏你现有的任何代码。只要记住以下规则：</p>
<ul class="simple">
<li><p>不要改变任何现有字段的字段号。</p></li>
<li><p>你添加的任何新字段都应该是可选的或重复的。这意味着任何由使用你的 “旧” 消息格式的代码序列化的消息可以被你的新生成的代码解析，因为它们不会缺少任何 <code class="docutils literal notranslate"><span class="pre">required</span></code> 元素。你应该为这些元素设置合理的默认值，这样新代码就可以与旧代码生成的消息正确地互动。同样，由你的新代码创建的消息可以被你的旧代码解析：旧的二进制文件在解析时只需忽略新字段。然而，未知字段不会被丢弃，如果消息后来被序列化，未知字段也会被一起序列化——所以如果消息被传递给新代码，新字段仍然可用。</p></li>
<li><p>非 <code class="docutils literal notranslate"><span class="pre">required</span></code> 字段可以被删除，只要字段号不会在你更新的消息类型中再次使用。你可能想重新命名这个字段，也许加上前缀 “OBSOLETE_”，或者让这个字段号保留下来，这样你的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 的未来用户就不能意外地重复使用这个号码。</p></li>
<li><p>一个非 <code class="docutils literal notranslate"><span class="pre">required</span></code> 字段可以转换为 <a class="reference external" href="#extensions">extension</a> 字段，反之亦然，只要类型和数字保持不变。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32</span></code>、<code class="docutils literal notranslate"><span class="pre">uint32</span></code>、<code class="docutils literal notranslate"><span class="pre">int64</span></code>、<code class="docutils literal notranslate"><span class="pre">uint64</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 都是兼容的——这意味着你可以将一个字段从这些类型中的一个改为另一个，而不会破坏向前或向后的兼容。如果从 wire 上解析出的数字不符合相应的类型，你会得到与你在 C++ 中把数字投到该类型的相同效果（例如，如果一个 64 位的数字被读成 <code class="docutils literal notranslate"><span class="pre">int32</span></code>，它将被截断为 32 位）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sint32</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sint64</span></code> 是相互兼容的，但与其他整数类型不兼容。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 包含信息的编码版本，则嵌入式信息与字节兼容。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed32</span></code> 与 <code class="docutils literal notranslate"><span class="pre">sfixed32</span></code> 兼容，而 <code class="docutils literal notranslate"><span class="pre">fixed64</span></code> 与 <code class="docutils literal notranslate"><span class="pre">sfixed64</span></code> 兼容。</p></li>
<li><p>对于 <code class="docutils literal notranslate"><span class="pre">string</span></code>、<code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和消息字段，<code class="docutils literal notranslate"><span class="pre">optional</span></code> 与 <code class="docutils literal notranslate"><span class="pre">repeated</span></code> 兼容。给出重复字段的序列化数据作为输入，如果是原始类型的字段，期望这个字段是 <code class="docutils literal notranslate"><span class="pre">optional</span></code> 客户端将采取最后的输入值，如果是消息类型的字段，将合并所有输入元素。请注意，这对于数字类型，包括 bool 和 <code class="docutils literal notranslate"><span class="pre">enum</span></code>，通常是不安全的。数字类型的重复字段可以用 <a class="reference external" href="https://developers.google.cn/protocol-buffers/docs/encoding#packed"><code class="docutils literal notranslate"><span class="pre">packed</span></code></a> 的格式进行序列化，当期望有一个 <code class="docutils literal notranslate"><span class="pre">optional</span></code> 字段时，这将不能被正确解析。</p></li>
<li><p>改变默认值一般是可以的，只要你记住默认值是不会在 wire 发送的。因此，如果一个程序收到一个没有设置特定字段的消息，该程序将看到默认值，因为它是在该程序的协议版本中定义的。它不会看到发件人代码中定义的默认值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span></code> 与 <code class="docutils literal notranslate"><span class="pre">int32</span></code>、<code class="docutils literal notranslate"><span class="pre">uint32</span></code>、<code class="docutils literal notranslate"><span class="pre">int64</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint64</span></code> 在 wire 格式上是兼容的（注意，如果数值不合适，会被截断），但是要注意，当消息被反序列化时，客户端代码可能会对它们进行不同的处理。值得注意的是，当消息被反序列化时，未被识别的 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 值会被丢弃，这使得字段的 <code class="docutils literal notranslate"><span class="pre">has..</span></code> 访问器返回 <code class="docutils literal notranslate"><span class="pre">false</span></code>，其 <code class="docutils literal notranslate"><span class="pre">getter</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 定义中列出的第一个值，或者默认值（如果指定了一个）。在重复 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 字段的情况下，任何未被识别的值都会从列表中剥离出来。然而，一个整数字段将始终保留其值。正因为如此，当把一个整数升级为 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 时，你需要非常小心，以免在电线上收到超界的 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 值。</p></li>
<li><p>在当前的 Java 和 C++ 实现中，当未识别的 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 值被剥离出来时，它们会与其他未知字段一起被存储。如果这些数据被序列化，然后被识别这些值的客户端重新解析，这可能导致奇怪的行为。在可选字段的情况下，即使在原始消息被反序列化后写了一个新的值，旧的值仍会被识别它的客户端读取。在重复字段的情况下，旧值将出现在任何已识别的和新添加的值之后，这意味着顺序将不会被保留下来。</p></li>
<li><p>将一个单一的可选值改成一个新的 <code class="docutils literal notranslate"><span class="pre">oneof</span></code> 的成员是安全的，而且二进制兼容。将多个可选字段移入一个新的 <code class="docutils literal notranslate"><span class="pre">oneof</span></code> 中可能是安全的，如果你确信没有代码同时设置多个字段的话。将任何字段移入一个现有的 <code class="docutils literal notranslate"><span class="pre">oneof</span></code> 中是不安全的。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">map&lt;K,</span> <span class="pre">V&gt;</span></code> 和相应的重复消息字段之间改变字段是二进制兼容的（关于消息布局和其他限制，见下文的 <a class="reference external" href="#maps">Maps</a>）。然而，改变的安全性取决于应用：当反序列化和重新序列化消息时，使用重复字段定义的客户端将产生一个语义上相同的结果；然而，使用 <code class="docutils literal notranslate"><span class="pre">map</span></code> 字段定义的客户端可能会重新排序条目并放弃有重复键的条目。</p></li>
</ul>
</div>
<div class="section" id="extensions">
<span id="id5"></span><h2>extensions<a class="headerlink" href="#extensions" title="永久链接至标题">¶</a></h2>
<p>扩展允许你声明信息中的一系列字段号码可用于第三方扩展。扩展是一个字段的占位符，其类型未被原始 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件定义。这允许其他 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件通过定义这些字段号的部分或全部字段的类型来增加你的消息定义。让我们看一个例子：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="k">extensions</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">199</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这说明 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 中字段号 <code class="docutils literal notranslate"><span class="pre">[100,</span> <span class="pre">199]</span></code> 的范围是保留给扩展的。其他用户现在可以在他们自己的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code> 文件中向 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 添加新的字段，这些文件可以导入你的 <code class="docutils literal notranslate"><span class="pre">.proto</span></code>，使用你指定范围内的字段号 - 例如：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">126</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这在 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的原始定义中增加了一个名为 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 的字段，字段号为 <code class="docutils literal notranslate"><span class="pre">126</span></code>。</p>
<p>当你的用户的 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 消息被编码时，wire 的格式与用户在 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 内部定义新字段的情况完全相同。然而，你在应用程序代码中访问扩展字段的方式与访问普通字段略有不同——你生成的数据访问代码有特殊的访问器用于处理扩展字段。因此，例如，这里是你如何在 C++ 中设置 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 的值。</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">foo.SetExtension</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span>
</pre></div>
</div>
<p>同样，<code class="docutils literal notranslate"><span class="pre">Foo</span></code> 类定义了模板化的访问器 <code class="docutils literal notranslate"><span class="pre">HasExtension()</span></code>、<code class="docutils literal notranslate"><span class="pre">ClearExtension()</span></code>、<code class="docutils literal notranslate"><span class="pre">GetExtension()</span></code>、<code class="docutils literal notranslate"><span class="pre">MutableExtension()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AddExtension()</span></code>。所有的语义都与正常字段的相应生成访问器相匹配。关于使用扩展的更多信息，请参见你所选择的语言的生成代码参考。</p>
<p>扩展可以是任何字段类型，包括消息类型，但不能是 oneofs 或 maps。</p>
<div class="section" id="id6">
<h3>嵌套扩展<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>你可以在另一个类型的范围内声明扩展：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Baz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">optional</span><span class="w"> </span><span class="kt">int32</span><span class="w"> </span><span class="na">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">126</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在这种情况下，访问这个扩展的 C++ 代码是：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
<span class="n">foo</span><span class="p">.</span><span class="n">SetExtension</span><span class="p">(</span><span class="n">Baz</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>换句话说，唯一的效果是，<code class="docutils literal notranslate"><span class="pre">bar</span></code> 被定义在 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 的范围内。</p>
<p>这是一个常见的混淆源。声明一个嵌套在消息类型内部的扩展块并不意味着外部类型和扩展类型之间的任何关系。特别是，上面的例子并不意味着 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的任何种类的子类。它只意味着符号 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 是在 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 的范围内声明的；它只是一个静态成员。</p>
<p>一个常见的模式是在扩展的字段类型的范围内定义扩展–例如，这里是对 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 类型的 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的扩展，其中扩展被定义为 <code class="docutils literal notranslate"><span class="pre">Baz</span></code> 的一部分：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Baz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">optional</span><span class="w"> </span><span class="n">Baz</span><span class="w"> </span><span class="na">foo_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">127</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然而，并不要求带有消息类型的扩展被定义在该类型内。你也可以这样做：</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Baz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>

<span class="c1">// This can even be in a different file.</span>
<span class="kd">extend</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">optional</span><span class="w"> </span><span class="n">Baz</span><span class="w"> </span><span class="na">foo_baz_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">127</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>事实上，为了避免混淆，这种语法可能是首选。如上所述，嵌套语法经常被那些还不熟悉扩展的用户误认为是子类。</p>
</div>
<div class="section" id="id7">
<h3>选择扩展编号<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>确保两个用户不使用相同的字段号为同一消息类型添加扩展名是非常重要的——如果一个扩展名被意外地解释为错误的类型，就会导致数据损坏。你可能想考虑为你的项目定义一个扩展编号惯例，以防止这种情况发生。</p>
<p>如果你的编号惯例可能涉及到扩展有非常大的字段号，你可以使用 <code class="docutils literal notranslate"><span class="pre">max</span></code> 关键字指定你的扩展范围，直到可能的最大字段号。</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">extensions</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">max</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">max</span></code> 是 <span class="math notranslate nohighlight">\(2^{29} - 1\)</span>。</p>
<p>如同在选择字段号时，你的编号惯例也需要避免字段号 19000 到 19999（<code class="docutils literal notranslate"><span class="pre">FieldDescriptor::kFirstReservedNumber</span></code> 到 <code class="docutils literal notranslate"><span class="pre">FieldDescriptor::kLastReservedNumber</span></code>），因为它们被保留给协议缓冲区的实现。你可以定义一个包括这个范围的扩展范围，但是协议编译器不允许你用这些数字定义实际的扩展。</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "xinetzone/protobuf-book",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./start"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>
<div class="section">
   
</div>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="proto3.html" title="上一页 页">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">上一页</p>
            <p class="prev-next-title">proto3</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="encoding.html" title="下一页 页">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">下一页</p>
        <p class="prev-next-title">编码</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
  <p>
    
      通过 xinetzone<br/>
    
        &copy; 版权 2021, xinetzone.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>